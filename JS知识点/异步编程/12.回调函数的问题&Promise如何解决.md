## 回调函数的问题


### 总结问题：回调地狱的根本问题就是：

1. 回调嵌套(回调地狱)： 
-  排斥问题难： 因为嵌套的书写模式，会让我们花更多的精力去梳理正确的执行顺序。代码不容易阅读，使得排查问题的难度也在成倍增加。
- 代码耦合：实际业务中，我们会把业务逻辑和异常处理都放入到函数中，会导致代码耦合。异常错误很难处理， 难以维护和更改。

2. 控制反转：当我们使用回调的时候，这个回调函数是否能接着执行，会不会被多次执行，是否不会执行，是否一会同步，一会异步的返回，其实取决于使用回调的那个 API。会导致控制权的丢失

3. 难以复用：回调的顺序确定下来之后，想对其中的某些环节进行复用也很困难，牵一发而动全身
4. 堆栈信息被断开：
- 将回调函数加入任务队列中，代码继续执行，直至主线程完成后，才会从任务队列中选择已经完成的任务，并将其加入栈中，此时栈中只有这一个执行上下文，如果回调报错，也无法获取调用该异步操作时的栈中的信息，不容易判定哪里出现了错误。

5. 借助外层变量


### 说起 Promise，我们一般都会从回调或者回调地狱说起，那么使用回调到底会导致哪些不好的地方呢？

1. 回调嵌套：使用回调，我们很有可能会将业务代码写成如下这种形式：

- 然而在实际的项目中，代码会更加杂乱，我们要多花一些精力去思考真正的执行顺序， 使得排查问题的难度也在成倍增加。

- 就比如在上面这个例子中，doD() 必须在 doC() 完成后才能完成，万一 doC() 执行失败了呢？我们是要重试 doC() 吗？还是直接转到其他错误处理函数中？当我们将这些判断都加入到这个流程中，很快代码就会变得非常复杂，以至于无法维护和更新。

2. 控制反转
正常书写代码的时候，我们理所当然可以控制自己的代码，然而当我们使用回调的时候，这个回调函数是否能接着执行，其实取决于使用回调的那个 API，

```txt
回调函数执行多次
回调函数没有执行
回调函数有时同步执行有时异步执行
```


3. 回调地狱：我们再来聊聊回调地狱的其他问题：
- 难以复用: 回调的顺序确定下来之后，想对其中的某些环节进行复用也很困难，牵一发而动全身。
- 堆栈信息被断开：解释如下
```txt
我们知道，JavaScript 引擎维护了一个执行上下文栈，当函数执行的时候，会创建该函数的执行上下文压入栈中，当函数执行完毕后，会将该执行上下文出栈。

如果 A 函数中调用了 B 函数，JavaScript 会先将 A 函数的执行上下文压入栈中，再将 B 函数的执行上下文压入栈中，当 B 函数执行完毕，将 B 函数执行上下文出栈，当 A 函数执行完毕后，将 A 函数执行上下文出栈。

这样的好处在于，我们如果中断代码执行，可以检索完整的堆栈信息，从中获取任何我们想获取的信息。

可是异步回调函数并非如此，比如执行 fs.readdir 的时候，其实是将回调函数加入任务队列中，代码继续执行，直至主线程完成后，才会从任务队列中选择已经完成的任务，并将其加入栈中，此时栈中只有这一个执行上下文，如果回调报错，也无法获取调用该异步操作时的栈中的信息，不容易判定哪里出现了错误。

此外，因为是异步的缘故，使用 try catch 语句也无法直接捕获错误。

(不过 Promise 并没有解决这个问题)
```
- 借助外层变量
```txt
当多个异步计算同时进行，比如这里遍历读取文件信息，由于无法预期完成顺序，必须借助外层作用域的变量，比如这里的 count、errored、stats 等，不仅写起来麻烦，而且如果你忽略了文件读取错误时的情况，不记录错误状态，就会接着读取其他文件，造成无谓的浪费。此外外层的变量，也可能被其它同一作用域的函数访问并且修改，容易造成误操作。

之所以单独讲讲回调地狱，其实是想说嵌套和缩进只是回调地狱的一个梗而已，它导致的问题远非嵌套导致的可读性降低而已。
```



## Promise解决了那些问题

1. 针对回调嵌套

- Promise使用then链来增加代码的可读性和可维护信息

2. 控制权反转的问题

- 前面我们讲到使用第三方回调 API 的时候，可能会遇到如下问题：
```txt
回调函数执行多次
回调函数没有执行
回调函数有时同步执行有时异步执行

对于第一个问题，Promise 只能 resolve 一次，剩下的调用都会被忽略。
对于第二个问题，我们可以使用 Promise.race 函数来解决：
对于第三个问题，为什么有的时候会同步执行有的时候回异步执行呢？
实践中要确保 onFulfilled 和 onRejected 方法异步执行，且应该在 then 方法被调用的那一轮事件循环之后的新执行栈中执行。
```

## Promise的局限

1. 错误被吃掉
```js
let promise = new Promise(() => {
    throw new Error('error')
});
console.log(2333333);
```
- 这次会正常的打印 233333，说明 Promise 内部的错误不会影响到 Promise 外部的代码，而这种情况我们就通常称为 “吃掉错误”。

- 其实这并不是 Promise 独有的局限性，try..catch 也是这样，同样会捕获一个异常并简单的吃掉错误。

- 而正是因为错误被吃掉，Promise 链中的错误很容易被忽略掉，这也是为什么会一般推荐在 Promise 链的最后添加一个 catch 函数，因为对于一个没有错误处理函数的 Promise 链，任何错误都会在链中被传播下去，直到你注册了错误处理函数。

2. 无法取消

- Promise 一旦新建它就会立即执行，无法中途取消。

3. 无法得知 pending 状态

- 当处于 pending 状态时，无法得知目前进展到哪一个阶段（刚刚开始还是即将完成）。




